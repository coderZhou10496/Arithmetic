//
//  main.cpp
//  376-WiggleSubsequence
//
//  Created by zhoujian on 2020/2/28.
//  Copyright © 2020 zhoujian. All rights reserved.
//

#include <iostream>
#include "vector"
using namespace std;

/*
 如果连续数字之间的差严格地在正数和负数之间交替，则数字序列称为摆动序列。第一个差（如果存在的话）可能是正数或负数。少于两个元素的序列也是摆动序列。
 
 例如， [1,7,4,9,2,5] 是一个摆动序列，因为差值 (6,-3,5,-7,3) 是正负交替出现的。相反, [1,4,7,2,5] 和 [1,7,4,5,5] 不是摆动序列，第一个序列是因为它的前两个差值都是正数，第二个序列是因为它的最后一个差值为零。
 
 给定一个整数序列，返回作为摆动序列的最长子序列的长度。 通过从原始序列中删除一些（也可以不删除）元素来获得子序列，剩下的元素保持其原始顺序。
 
 示例 1:
 
 输入: [1,7,4,9,2,5]
 输出: 6
 解释: 整个序列均为摆动序列。
 示例 2:
 
 输入: [1,17,5,10,13,15,10,5,16,8]
 输出: 7
 解释: 这个序列包含几个长度为 7 摆动序列，其中一个可为[1,17,10,13,10,16,8]。
 示例 3:
 
 输入: [1,2,3,4,5,6,7,8,9]
 输出: 2
 
 来源：力扣（LeetCode）
 链接：https://leetcode-cn.com/problems/wiggle-subsequence
 著作权归领扣网络所有。商业转载请联系官方授权，非商业转载请注明出处。
 
 */

int wiggleMaxLength(vector<int>& nums) {
    if(nums.empty()) {
        return 0;
    }
    if(nums.size() < 2) {
        return 1;
    }
    /*
     dp[i][0]:以第i位结尾，并且nums[i-1] > nums[i]的最长摆动序列(到第i位是减)
     dp[i][1]:以第i位结尾，并且nums[i-1] < nums[i]的最长摆动序列(到第i位是增)
     */
    vector<vector<int>> dp(nums.size(), vector<int>(2,1));
    
    for(int i = 1; i < nums.size(); i++) {
        for(int j = 0; j < i; j++) {
            if(nums[j] > nums[i]) {
                dp[i][0] = max(dp[i][0], dp[j][1]+1);
            }
            if(nums[j] < nums[i]) {
                dp[i][1] = max(dp[i][1], dp[j][0]+1);
            }
        }
    }
    return max(dp[nums.size()-1][0], dp[nums.size()-1][1]);
}

// 解法二:线性动态规划

int wiggleMaxLength_solution2(vector<int>& nums) {
    if(nums.empty()) {
        return 0;
    }
    if(nums.size() < 2) {
        return 1;
    }
    /*
     up[i]:目前为止最长的以第i个元素结尾的上升摆动序列的长度
     down[i]:目前为止最长的以第i个元素结尾的下降摆动序列的长度
     */
    vector<int> up(nums.size(),1);
    vector<int> down(nums.size(),1);
    for(int i = 1; i < nums.size(); i++) {
        if(nums[i-1] < nums[i]) {
            up[i] = down[i-1] + 1;
            down[i] = down[i-1];
        }
        else if (nums[i-1] > nums[i]) {
            up[i] = up[i-1];
            down[i] = up[i-1] + 1;
        }
        else {
            down[i] = down[i-1];
            up[i] = up[i-1];
            
        }
    }
    
    return max(up[nums.size()-1], down[nums.size()-1]);
}
int main(int argc, const char * argv[]) {
    vector<int> nums = {257,126,189,342,294,160,0,273,336,233,45,313,288,359,395,128,42,180,240,191,103,327,285,353,228,268,351,7,263,6,321,293,19,93,140,301,282,374,301,251,138,246,178,314,129,149,255,96,170,371,233,93,348,286,289,239,49,127,137,103,290,44,299,138,228,204,346,147,317,48,263,321,249,255,362,366,331,325,384,100,63,261,286,140,383,156,20,381,205,133,126,209,355,212,341,243,45,258,272,201,57,346,374,190,109,240,98,40,145,383,340,5,341,302,355,75,331,352,75,132,219,230,363,207,288,344,278,219,361,168,375,337,46,273,258,266,40,19,57,308,327,79,204,206,357,268,74,296,352,57,306,181,116,59,218,122,297,298,43,23,9,271,17,145,123,257,338,267,313,245,279,229,168,253,318,139,28,121,363,347,138,240,357,129,65,32,91,365,114,87,362,391,396,290,157,28,123,238,326,283,200,393,48,284,117,347,293,100,177,8,243,41,349,164,66,15,219,245,210,242,229,364,211,139,306,67,171,69,43,394,163,106,186,347,252,239,159,287,396,180,378,75,276,106,66,393,369,21,121,12,150,250,46,281,11,295,174,239,178,57,236,292,100,143,83,221,154,342,178,83,375,56,324,3,133,242,182,217,161,310,363,177,378,361,394,233,39,137,398,42,273,203,155,333,194,384,274,33,20,192,280,300,177,268,262,45,219,367,260,95,328,238,127,265,42,199,12,368,63,136,294,381,362,220,279,177,193,126,169,127,208,87,27,365,322,50,383,96,304,328,207,244,121,108,241,161,269,40,31,218,277,278,52,253,367,361,381,18,258,177,275,335,154,196,61,100,305,302,80,212,335,186,36,113,71,302,398,2,23,352,316,190,80,231,25,356,103,24,147,289,123,306,69,368,310,292,262,363,369,143};
    
    vector<int> nums2 = {1,7,4,9,2,5};
    cout << wiggleMaxLength_solution2(nums) << endl;
    return 0;
}
